Чтобы сделать аннотацию доступной в рантайме надо прописать @Retantion
@Inherited - означает, что аннотация автоматически наследуется

//------Классы внутри классов Inner (динамический)

INNER класс - это класс, описаный внутри другого класса.
У него могут юыть модификаторы интересны.
Основной бенефит в том, что внутренние классы имеют доступ к приватным полям классов-контейнеров.
Внутренние классы не могут содержать статические поля, кроме final static.

Доступ к полям <класс контейнер>.<внутренний класс>.<имя поля>

Внутренние классы могут быть производными от других  классов.
Внутренние классы могут реализовывать интерфейсы.

Внутренний класс может быть объявлен внутри метода или логического блока внешнего класса.
Не рекомендуется делать большими классы. Из внутреннего класса можно обращаться ко полям блока только типа final.
Замыкание -сохранение переменных контекста. В java замыкания нет.

//------Классы внутри классов Nested (статический)

static class Inner1 {..}
Можно обращаться только к статическим полям внешнего класса. Для этого надо создавать экземпляр внешнего класса.
Вызов класса:
Outer11.Inner1.method();

//-- Класы внутри классов Anonymus
Пример смотри в классе.


//- Дефолтные и статические методы в интерфейсах (java 8)
//--- Лямбда выражения
Лямбда выражением можно определять только интерфейс - оно не может представлять собой наследника класса,
 в т.ч. абстрактного класса с одним абстрактным методом
 > зато такой функционал доступен в Nashorn'e (реализация JavaScrip через Scripting API)
 Лямбдой можно определить лишь функциональный интерфейс
     функциональным интерфейсом называют интерфейс:
    - содержащий лишь один абстрактный метод
    - не предполагающий обладания состоянием
     для того, чтобы компилятор следил за тем, что бы интерфейс отвечал требованию функционального,
     принято перед ним аннотацию @FunctionalInterface

     Некоторые интерфейсы не имеют такой аннотации (Comparable, Closeable);

     Ключевое слово this из лямбда выражения попадает в замыкание, в отличии от анонимного класса.

     Все внешние переменные, которые используются в лямбда-выражении, не обязаны быть final,
     потому что компилятор сам делает final переменные. В доккументации это называется "effectively final"

     При компиляции не формируется отдельный класс для лямбды.

//--- Design Pattern.
//---GRASP.CREATOR

Наиболее частой проблемой ОО-дизайна является проблема "Кто должен создавать объект Х?" Объект А должен создовать
объект B если:
- А содержит или агрегирует В
- А записывает В
- А широко использует В
- А ....
//--- GRASP.LOW COUPING

//----------STRING
