Самосортирующиеся объекты используются крайне редко.
Comporator помогает при сортировке, он является критерием.
Пример:
int compare(T ob1. T ob2);
//------Параметрические классы
Пример шаблона с двумя параметрами:
public class Message <T1, T2> {
    T1 id;
    T2 name;
    }
ещё пример:
Massage <Integer, String> ob=new Message <integer, String> ();
с седьмой джавы:
Massage <Integer, String> ob=new Message <> ();

ещё пример:
public class Optional <T> {
private T value;
public Optional(){
}
public
}

// Ограничение типов. Т - должно наследоваться от типа (или быть этим типом)
public class OptionalExt <T extends ТИП> {
    private T value;
}
Или используется метасимвол:
public class OptionalExt <? extends ТИП> {
    private T value;
}

Использование super:
List<? super Doctor> list7=new ArrayList<MedicalStaff>();

generic в статических методах:
<T extends Тип> Тип method (T args) {}
<T> тип method (T args) {}

public static <T extends Number> byte asByte(T num) {
    long n=num.longValue();
}
нельзя явно вызывать конструктор параметрического класса!

//--Перечисления

public enum Season {
    WINTER,
    STRING,
    SUMMER,
    FALL
}

Транзитивная зависимость - это случай, когда мы знаем, что точно понадобится
Опциональная зависимость - это случай, когда не уверены.

Если зависимость транзитивна, то мы выбираем eadger или lazy инициализацию в зависимости от того, когда удобнее
запустить объект. Lazy делается при опциональной зависимости (это наиболее часто).

Есть пересичления

Аннотации в коде ничего не делают, но несут информацию. Помогает при взаимодействии с другим кодом.
Три типа аннотаций:
1) Информация для компилятора - чтобы компилятор мог обнаружить ошибку. В байткоде этих аннотаций нет
2) Compiler-time and deployment-time processing - Аннотации не для компилятора и сохраняется в байткоде.
JIT компилятор выкидывает эти аннотации. (Этот тип стоит по дефолту, нужно менять!)
3) Runtime processing - некоторые аннотации доступны во время выполнения программы

Что можно аннотированть:
Класс, интерфейс и перечисления
свойства
Методы, консрукторы и параметры методов
локальная переменная
блок catch
пакет (package-info.java)
другая аннотация

@SuppressWarnings(value="unchecked")
или
@SuppressWarnings("unchecked")  (т.к. только один параметр у аннотации и он называется value)

@Override - говорит компилятору, чтобы он проверил, переопределён ли метод

Определение своей аннотации:
@interface ClassPreamble {
    String author();
    String date();
    int currentRevision() default 1;
    String lastModified() default "N/A"
    String lastModifiedBy() default "N/A"
    String[] reviewers();
}

Применение:
@ClassPreamble(
    author = "John"
    ....
    ...
    ...
    }

    @Target(ElementType.TYPE) - показывает, к какому типу применима аннотация
    @Retention

Предопределённые аннотации
@Depricated
@Override
@SuppressWarnings

lambok